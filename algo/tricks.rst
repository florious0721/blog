技巧
####

避免拷贝
--------

对大量的数据记得使用引用或指针来避免拷贝。

全局变量
--------

函数里直接开超大数组可能会段错误，
可以直接用全局变量开大数组。

.. _prefix_sum:

前缀和
------

前缀和就是将序列的前 :math:`n` 项和存储起来，
之后我们就可以以 :math:`O(1)` 的时间获取任意区间的和。

.. _max_interval_sum:

求最大区间和
------------

用 :math:`S_i` 表示序列的前 :math:`i` 项和。
那么长度为 :math:`r` 的序列的最大后缀和就是
:math:`M_r = S_r - min \lbrace S_i | i \in (0, r) \rbrace`。
对一个长度为 :math:`n` 的序列，我们只要求
:math:`M = max \lbrace M_r | r \in [1, n] \rbrace`
即为它的最大区间和。

滑动窗口
--------

用单调队列解决滑动窗口最值的问题。
通常先将输入完整地存放到数组里，
用单调队列存储元素下标。
也可以不用完整地存储输入，
而将元素及其下标一起存到单调队列里。

例题

* :ref:`lgp1440`
* :ref:`lc239`

.. _log_position:

记录位置
--------

在返回序列中索引或统计序列中出现次数时可以用记录位置，
将项在序列中出现的索引用数组记录下来。

例题

* :ref:`lc2080`

.. _binary_answer:

二分答案
--------

首先我们有一系列可按顺序查询答案，
这些答案中包含可行解、最优解、不可行解。

如果答案的顺序符合

* 最优解的左侧全是可行解，最优解的右侧全是不可行解

或

* 最优解的右侧全是可行解，最优解的左侧全是不可行解

那么我们就可以使用二分答案，下面以
最优解的左侧全是可行解，最优解的右侧全是不可行解
的情况为例说明如何使用：

#. 左边界设为第一个答案，右边界设为最后一个答案。
#. 取这两个边界内中间的答案，
   如果它是可行解，将左边界设为这个答案；
   如果它是不可行解，将右边界设为这个答案。
#. 重复直到左右边界重合或交错。

最优解是最后找到的可行解。
