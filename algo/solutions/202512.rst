2025 年 12 月
#############

:luogu:`P1030`
--------------

  给出一棵二叉树的中序与后序排列。
  求出它的先序排列。
  （约定树结点用不同的大写字母表示，
  且二叉树的节点个数 ≤ 8）。

根据后序排列的定义，
每棵树后序排列的最后一项一定是这棵树的根，
问题在于如何确定左子树和右子树。
我们可以在中序排列中找到树的根，
中序排列中根的左侧是左子树，右侧是右子树，
对应地我们可以求出两边子树的项数，
然后在后序排列中再确定左子树、右子树的根，
递归直到排列长度为 1 或 0。

.. code:: cpp

  #include <cstdio>
  #include <ctype.h>
  char in[0x10] = {0};
  char post[0x10] = {0};
  char tree[0x10] = {0};
  void build(char *cin, char *cpost, int len, int idx) {
      if (len == 0) return;
      if (len == 1) {
          tree[idx] = *cpost;
          return;
      }
      char *lin, *lpost, *rin, *rpost;
      int llen, rlen;

      char c = cpost[len - 1];
      for (int i = 0; i < len; ++i) {
          if (cin[i] == c) {
              lin = cin;
              lpost = cpost;
              llen = i;
              rin = cin + i + 1;
              rpost = cpost + i;
              rlen = len - i - 1;
              break;
          }
      }
      tree[idx] = c;
      build(lin, lpost, llen, 2 * idx + 1);
      build(rin, rpost, rlen, 2 * idx + 2);
  }

  void pre(int idx) {
      if (tree[idx] == 0) return;
      putchar(tree[idx]);
      pre(2 * idx + 1);
      pre(2 * idx + 2);
  }

  int main(void) {
      char in[0x10] = {0};
      char post[0x10] = {0};
      char ch;
      int i = 0;

      do {
          ch = getchar();
          in[i++] = ch;
      } while (isalpha(ch));

      while (isspace(ch)) ch = getchar();

      i = 0;
      while (isalpha(ch)) {
          post[i++] = ch;
          ch = getchar();
      }

      build(in, post, i, 0);
      pre(0);
  }

:luogu:`P1229`
--------------

  已知二叉树的前序和后序遍历，求它可能的中序遍历的总数。

前序遍历中当前项的下一项一定是当前项的子节点；
后序遍历中当前项的前一项一定是当前项的子节点。
根据这两点我们先确定当前节点是有一个子节点还是两个子节点。

如果有两个子节点，那么当前节点是确定的。
一定是前序遍历中下一项为左子节点，
后序遍历中前一项为右子节点，
可能的中序遍历总数不变。
我们再在前序和后序遍历中分割出左子树和右子树递归求解即可。

否则当前节点只有一个子节点，它可能是左子节点或右子节点。
对应地，可能的中序遍历总数乘 2。
将前序和后序遍历除掉当前项，剩余项都是这一棵子树上的节点，
递归求解即可。

当节点数小于 2 时结束递归。


.. code:: cpp

  #include <cctype>
  #include <cstdio>
  void f(char *cpre, char *cpost, int len, int *r) {
      if (len < 2) return;
      char lnode = cpre[1];
      char rnode = cpost[len - 2];
      if (lnode == rnode) {
          *r *= 2;
          f(cpre + 1, cpost, len - 1, r);
      } else {
          int i = 0;
          for (; i < len - 2; ++i) {
              if (cpost[i] == lnode) break;
          }
          int llen = i + 1;
          int rlen = len - llen - 1;
          f(cpre + 1, cpost, llen, r);
          f(cpre + 1 + llen, cpost + llen, rlen, r);
      }
  }

  int main(void) {
      char pre[0x20];
      char post[0x20];
      int len = 0;
      int r = 1;

      char ch = 0;
      for (;;) {
          ch = getchar();
          if (!isalpha(ch)) break;
          pre[len++] = ch;
      }
      len = 0;
      for (;;) {
          ch = getchar();
          if (isalpha(ch)) break;
      }
      while (isalpha(ch)) {
          post[len++] = ch;
          ch = getchar();
      }
      f(pre, post, len, &r);
      printf("%d\n", r);
      return 0;
  }

:luogu:`P1090`
--------------

凭感觉应该是每次都把最小的两堆合并，
直到只剩最后一堆为止。
所以可以使用优先队列。

.. code:: cpp

  #include <cstdio>
  #include <queue>
  #include <vector>

  using namespace std;
  typedef unsigned int uint;
  int main(void) {
      priority_queue<uint, vector<uint>, greater<uint>> q;
      int n = 0;
      scanf("%d", &n);
      for (int i = 0; i < n; i++) {
          uint j = 0;
          scanf("%u", &j);
          q.push(j);
      }
      uint r = 0;
      for (;;) {
          int a = q.top();
          q.pop();
          if (q.empty()) {
              printf("%u", r);
              return 0;
          }
          int b = q.top();
          q.pop();
          q.push(a + b);
          r += a + b;
      }
  }

:luogu:`P1168`
--------------

最理想的条件当然是维护一个有序的序列，
在每次插入新值时确保插入的位置依然能使序列有序。
能够维护有序序列的就是堆，但是堆只能取堆顶，
而这里需要的是中位数。
于是我们可以用两个堆，分别存储较大的数和较小的数，
存储较大的数的堆是小顶堆，
存储较小的数的堆是大顶堆，
这样我们就能快速取出在插入新值后可能成为新的中位数的值。

对于每个新插入的值，我们取两个堆的堆顶，
新的中位数一定在这三个值之间，判断出新的中位数后
再按三个数的大小关系放回堆里即可。

.. code:: cpp

  #include <cstdio>
  #include <cstdlib>
  #include <queue>
  #include <vector>
  using namespace std;
  typedef unsigned int uint;
  int main(void) {
      priority_queue<uint, vector<uint>> qbig; // 大顶堆，存的数比 mid 小
      priority_queue<uint, vector<uint>, greater<uint>> qsmall; // 小顶堆，存的数比 mid 大
      int n = 0;
      scanf("%d", &n);

      uint j = 0, k = 0;
      scanf("%u%u", &j, &k);
      printf("%u\n", j);
      if (j < k) {
          qbig.push(j);
          qsmall.push(k);
      } else {
          qbig.push(k);
          qsmall.push(j);
      }

      for (int i = 2; i < n; ++i) {
          uint j = 0;
          scanf("%u", &j);

          uint l = qbig.top();
          qbig.pop();
          uint r = qsmall.top();
          qsmall.pop();
          if (r <= j) {
              // l <= r <= j
              if (qbig.size() <= qsmall.size()) {
                  qbig.push(l);
                  qbig.push(r);
                  qsmall.push(j);
              } else {
                  qbig.push(l);
                  qsmall.push(r);
                  qsmall.push(j);
              }
          } else if (j <= l) {
              // j <= l <= r
              if (qbig.size() <= qsmall.size()) {
                  qbig.push(j);
                  qbig.push(l);
                  qsmall.push(r);
              } else {
                  qbig.push(j);
                  qsmall.push(l);
                  qsmall.push(r);
              }
          } else {
              // l <= j <= r
              if (qbig.size() <= qsmall.size()) {
                  qbig.push(l);
                  qbig.push(j);
                  qsmall.push(r);
              } else {
                  qbig.push(l);
                  qsmall.push(j);
                  qsmall.push(r);
              }
          }
          if (qbig.size() - 1 == qsmall.size()) {
              printf("%u\n", qbig.top());
          } else if (qbig.size() != qsmall.size()) {
              abort();
          }
      }
  }

:luogu:`P1102`
--------------

和 A+B 一样用哈希表。

哈希表用于存储数列中数的出现次数。

对每个插入的新值，先找找表内是否有符合条件的数，
如果有那么答案加上已有的符合条件的数的出现次数，
然后再把新值在表内对应的出现次数 +1。

.. code:: cpp

  #include <cstdio>
  #include <unordered_map>
  using namespace std;
  typedef unsigned long uint;
  using M = unordered_map<uint, uint>;
  int main(void) {
      uint r = 0;
      uint N, C;
      M m;
      scanf("%lu%lu", &N, &C);
      for (uint i = 0; i < N; ++i) {
          uint j = 0;
          scanf("%lu", &j);
          auto it = m.find(j);
          if (it == m.end()) m[j] = 1;
          else it->second++;

          uint k = j + C;
          it = m.find(k);
          if (it != m.end()) {
              r += it->second;
          }
          if (j - C > 0) {
              k = j - C;
              it = m.find(k);
              if (it != m.end()) r += it->second;
          }
      }
      printf("%lu", r);
  }

:luogu:`P2678`
--------------

最短跳跃距离的最大值满足 :ref:`binary_answer` 条件，
只要构造用于判断答案是否为可行解的方法即可。

对跳石头的过程进行模拟，
如果其中一次跳跃的距离小于当前被检验的答案，说明需要移走一块石头，
进行一次模拟统计需要移走的石头数量，若大于 M 说明答案为不可行解，否则为可行解。

.. code:: cpp

  #include <cstdio>
  using ui = unsigned int;

  ui distances[50000 + 0x100] = {0};

  static inline bool qualify(ui len, ui mid, ui m) {
      ui removed = 0;
      ui now = 0, next = 1;
      for (; now < len;) {
          ui d = distances[next] - distances[now];
          if (d < mid) {
              removed++;
              next++;
          } else {
              now = next;
              next++;
          }
      }
      if (removed > m) return false;
      else return true;
  }

  int main(void) {
      ui L, N, M;
      scanf("%u%u%u", &L, &N, &M);
      ui i = 1;
      for (; i <= N; i++) {
          ui j = 0;
          scanf("%u", &j);
          distances[i] = j;
      }
      distances[i] = L;
      ui l = 1, r = L;
      ui ans = 1;
      while (l <= r) {
          ui mid = (l + r) / 2;
          if (qualify(N + 2, mid, M)) {
              ans = mid;
              l = mid + 1;
          } else {
              r = mid - 1;
          }
      }
      printf("%u\n", ans);
  }
