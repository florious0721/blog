2025 年 12 月
#############

:luogu:`P1030`
--------------

  给出一棵二叉树的中序与后序排列。
  求出它的先序排列。
  （约定树结点用不同的大写字母表示，
  且二叉树的节点个数 ≤ 8）。

根据后序排列的定义，
每棵树后序排列的最后一项一定是这棵树的根，
问题在于如何确定左子树和右子树。
我们可以在中序排列中找到树的根，
中序排列中根的左侧是左子树，右侧是右子树，
对应地我们可以求出两边子树的项数，
然后在后序排列中再确定左子树、右子树的根，
递归直到排列长度为 1 或 0。

.. code:: cpp

  #include <cstdio>
  #include <ctype.h>
  char in[0x10] = {0};
  char post[0x10] = {0};
  char tree[0x10] = {0};
  void build(char *cin, char *cpost, int len, int idx) {
      if (len == 0) return;
      if (len == 1) {
          tree[idx] = *cpost;
          return;
      }
      char *lin, *lpost, *rin, *rpost;
      int llen, rlen;

      char c = cpost[len - 1];
      for (int i = 0; i < len; ++i) {
          if (cin[i] == c) {
              lin = cin;
              lpost = cpost;
              llen = i;
              rin = cin + i + 1;
              rpost = cpost + i;
              rlen = len - i - 1;
              break;
          }
      }
      tree[idx] = c;
      build(lin, lpost, llen, 2 * idx + 1);
      build(rin, rpost, rlen, 2 * idx + 2);
  }

  void pre(int idx) {
      if (tree[idx] == 0) return;
      putchar(tree[idx]);
      pre(2 * idx + 1);
      pre(2 * idx + 2);
  }

  int main(void) {
      char in[0x10] = {0};
      char post[0x10] = {0};
      char ch;
      int i = 0;

      do {
          ch = getchar();
          in[i++] = ch;
      } while (isalpha(ch));

      while (isspace(ch)) ch = getchar();

      i = 0;
      while (isalpha(ch)) {
          post[i++] = ch;
          ch = getchar();
      }

      build(in, post, i, 0);
      pre(0);
  }

:luogu:`P1229`
--------------

  已知二叉树的前序和后序遍历，求它可能的中序遍历的总数。

前序遍历中当前项的下一项一定是当前项的子节点；
后序遍历中当前项的前一项一定是当前项的子节点。
根据这两点我们先确定当前节点是有一个子节点还是两个子节点。

如果有两个子节点，那么当前节点是确定的。
一定是前序遍历中下一项为左子节点，
后序遍历中前一项为右子节点，
可能的中序遍历总数不变。
我们再在前序和后序遍历中分割出左子树和右子树递归求解即可。

否则当前节点只有一个子节点，它可能是左子节点或右子节点。
对应地，可能的中序遍历总数乘 2。
将前序和后序遍历除掉当前项，剩余项都是这一棵子树上的节点，
递归求解即可。

当节点数小于 2 时结束递归。


.. code:: cpp

  #include <cctype>
  #include <cstdio>
  void f(char *cpre, char *cpost, int len, int *r) {
      if (len < 2) return;
      char lnode = cpre[1];
      char rnode = cpost[len - 2];
      if (lnode == rnode) {
          *r *= 2;
          f(cpre + 1, cpost, len - 1, r);
      } else {
          int i = 0;
          for (; i < len - 2; ++i) {
              if (cpost[i] == lnode) break;
          }
          int llen = i + 1;
          int rlen = len - llen - 1;
          f(cpre + 1, cpost, llen, r);
          f(cpre + 1 + llen, cpost + llen, rlen, r);
      }
  }

  int main(void) {
      char pre[0x20];
      char post[0x20];
      int len = 0;
      int r = 1;

      char ch = 0;
      for (;;) {
          ch = getchar();
          if (!isalpha(ch)) break;
          pre[len++] = ch;
      }
      len = 0;
      for (;;) {
          ch = getchar();
          if (isalpha(ch)) break;
      }
      while (isalpha(ch)) {
          post[len++] = ch;
          ch = getchar();
      }
      f(pre, post, len, &r);
      printf("%d\n", r);
      return 0;
  }

:luogu:`P1090`
--------------

凭感觉应该是每次都把最小的两堆合并，
直到只剩最后一堆为止。
所以可以使用优先队列。

.. code:: cpp

  #include <cstdio>
  #include <queue>
  #include <vector>

  using namespace std;
  typedef unsigned int uint;
  int main(void) {
      priority_queue<uint, vector<uint>, greater<uint>> q;
      int n = 0;
      scanf("%d", &n);
      for (int i = 0; i < n; i++) {
          uint j = 0;
          scanf("%u", &j);
          q.push(j);
      }
      uint r = 0;
      for (;;) {
          int a = q.top();
          q.pop();
          if (q.empty()) {
              printf("%u", r);
              return 0;
          }
          int b = q.top();
          q.pop();
          q.push(a + b);
          r += a + b;
      }
  }

:luogu:`P1168`
--------------

最理想的条件当然是维护一个有序的序列，
在每次插入新值时确保插入的位置依然能使序列有序。
能够维护有序序列的就是堆，但是堆只能取堆顶，
而这里需要的是中位数。
于是我们可以用两个堆，分别存储较大的数和较小的数，
存储较大的数的堆是小顶堆，
存储较小的数的堆是大顶堆，
这样我们就能快速取出在插入新值后可能成为新的中位数的值。

对于每个新插入的值，我们取两个堆的堆顶，
新的中位数一定在这三个值之间，判断出新的中位数后
再按三个数的大小关系放回堆里即可。

.. code:: cpp

  #include <cstdio>
  #include <cstdlib>
  #include <queue>
  #include <vector>
  using namespace std;
  typedef unsigned int uint;
  int main(void) {
      priority_queue<uint, vector<uint>> qbig; // 大顶堆，存的数比 mid 小
      priority_queue<uint, vector<uint>, greater<uint>> qsmall; // 小顶堆，存的数比 mid 大
      int n = 0;
      scanf("%d", &n);

      uint j = 0, k = 0;
      scanf("%u%u", &j, &k);
      printf("%u\n", j);
      if (j < k) {
          qbig.push(j);
          qsmall.push(k);
      } else {
          qbig.push(k);
          qsmall.push(j);
      }

      for (int i = 2; i < n; ++i) {
          uint j = 0;
          scanf("%u", &j);

          uint l = qbig.top();
          qbig.pop();
          uint r = qsmall.top();
          qsmall.pop();
          if (r <= j) {
              // l <= r <= j
              if (qbig.size() <= qsmall.size()) {
                  qbig.push(l);
                  qbig.push(r);
                  qsmall.push(j);
              } else {
                  qbig.push(l);
                  qsmall.push(r);
                  qsmall.push(j);
              }
          } else if (j <= l) {
              // j <= l <= r
              if (qbig.size() <= qsmall.size()) {
                  qbig.push(j);
                  qbig.push(l);
                  qsmall.push(r);
              } else {
                  qbig.push(j);
                  qsmall.push(l);
                  qsmall.push(r);
              }
          } else {
              // l <= j <= r
              if (qbig.size() <= qsmall.size()) {
                  qbig.push(l);
                  qbig.push(j);
                  qsmall.push(r);
              } else {
                  qbig.push(l);
                  qsmall.push(j);
                  qsmall.push(r);
              }
          }
          if (qbig.size() - 1 == qsmall.size()) {
              printf("%u\n", qbig.top());
          } else if (qbig.size() != qsmall.size()) {
              abort();
          }
      }
  }

:luogu:`P1102`
--------------

和 A+B 一样用哈希表。

哈希表用于存储数列中数的出现次数。

对每个插入的新值，先找找表内是否有符合条件的数，
如果有那么答案加上已有的符合条件的数的出现次数，
然后再把新值在表内对应的出现次数 +1。

.. code:: cpp

  #include <cstdio>
  #include <unordered_map>
  using namespace std;
  typedef unsigned long uint;
  using M = unordered_map<uint, uint>;
  int main(void) {
      uint r = 0;
      uint N, C;
      M m;
      scanf("%lu%lu", &N, &C);
      for (uint i = 0; i < N; ++i) {
          uint j = 0;
          scanf("%lu", &j);
          auto it = m.find(j);
          if (it == m.end()) m[j] = 1;
          else it->second++;

          uint k = j + C;
          it = m.find(k);
          if (it != m.end()) {
              r += it->second;
          }
          if (j - C > 0) {
              k = j - C;
              it = m.find(k);
              if (it != m.end()) r += it->second;
          }
      }
      printf("%lu", r);
  }

:luogu:`P2678`
--------------

最短跳跃距离的最大值满足 :ref:`binary_answer` 条件，
只要构造用于判断答案是否为可行解的方法即可。

对跳石头的过程进行模拟，
如果其中一次跳跃的距离小于当前被检验的答案，说明需要移走一块石头，
进行一次模拟统计需要移走的石头数量，若大于 M 说明答案为不可行解，否则为可行解。

.. code:: cpp

  #include <cstdio>
  using ui = unsigned int;

  ui distances[50000 + 0x100] = {0};

  static inline bool qualify(ui len, ui mid, ui m) {
      ui removed = 0;
      ui now = 0, next = 1;
      for (; now < len;) {
          ui d = distances[next] - distances[now];
          if (d < mid) {
              removed++;
              next++;
          } else {
              now = next;
              next++;
          }
      }
      if (removed > m) return false;
      else return true;
  }

  int main(void) {
      ui L, N, M;
      scanf("%u%u%u", &L, &N, &M);
      ui i = 1;
      for (; i <= N; i++) {
          ui j = 0;
          scanf("%u", &j);
          distances[i] = j;
      }
      distances[i] = L;
      ui l = 1, r = L;
      ui ans = 1;
      while (l <= r) {
          ui mid = (l + r) / 2;
          if (qualify(N + 2, mid, M)) {
              ans = mid;
              l = mid + 1;
          } else {
              r = mid - 1;
          }
      }
      printf("%u\n", ans);
  }

:luogu:`P1883`
--------------

三分，设左、右边界分别为 l, r，设左、右三分点分别为 limd, rmid。
若 F(lmid) < F(rmid)，将右边界设为当前的右三分点，
否则将左边界设为当前的左三分点。

.. code:: cpp

  #include <cstdio>
  #include <cmath>

  #define EPS 1e-9
  int abcs[10000 + 0x100][3];

  double f(double x, int n) {
      double rmax = -INFINITY;
      for (int i = 0; i < n; i++) {
          double y = abcs[i][0] * x * x + abcs[i][1] * x + abcs[i][2];
          rmax = y > rmax ? y : rmax;
      }
      return rmax;
  }

  void algo(void) {
      int n = 0;
      scanf("%d", &n);
      for (int i = 0; i < n; i++) scanf("%d%d%d", abcs[i], abcs[i] + 1, abcs[i] + 2);

      double l = 0., r = 1000.;
      while (fabs(r - l) > EPS) {
          double lmid = (l * 2 + r) / 3;
          double rmid = (l + r * 2) / 3;
          if (f(lmid, n) < f(rmid, n)) {
              r = rmid;
          } else {
              l = lmid;
          }
      }
      printf("%.4lf\n", f(l, n));
  }

  int main(void) {
      int T = 0;
      scanf("%d", &T);
      for (int i = 0; i < T; ++i) algo();
  }

:luogu:`P1093`
--------------

自定义排序函数即可。

.. code:: cpp

  #include <cstdio>
  #include <algorithm>
  #include <vector>
  using namespace std;
  typedef struct {
      int id;
      int score1;
      int score2;
      int score3;
  } Student;

  bool cmp(Student const& l, Student const &r) {
      auto ltotal = l.score1 + l.score2 + l.score3;
      auto rtotal = r.score1 + r.score2 + r.score3;
      if (ltotal > rtotal) {
          return true;
      } else if (ltotal == rtotal) {
          if (l.score1 > r.score1) {
              return true;
          } else if (l.score1 == r.score1) {
              return l.id < r.id;
          } else {
              return false;
          }
      } else {
          return false;
      }
  }


  int main(void) {
      vector<Student> v;
      int n = 0;
      scanf("%d", &n);
      v.resize(n + 0x100);
      for (int i = 0; i < n; i++) {
          v[i].id = i + 1;
          scanf("%d%d%d", &v[i].score1, &v[i].score2, &v[i].score3);
      }
      sort(v.begin(), v.end(), cmp);
      for (int i = 0; i < 5; i++) {
          printf("%d %d\n", v[i].id, v[i].score1 + v[i].score2 + v[i].score3);
      }
  }

:leetcode:`274`
---------------

我的思路是先进行排序，然后从最高引用次数开始递减，
直到有足够多的论文高于当前引用次数为止。
看了其他题解才发现排序部分可以用计数排序优化，
也可以直接用二分答案解。

.. code:: cpp

  class Solution {
  public:
      int hIndex(vector<int>& citations) {
          std::sort(citations.begin(), citations.end(), [](int l, int r) {return l > r;});
          int h = citations[0];
          while (h > 0) {
              bool ok = true;
              if (citations.size() < h) {
                  h--;
                  continue;
              }
              for (int i = 0; i < citations.size() && i < h; i++) {
                  if (citations[i] < h) {
                      ok = false;
                      break;
                  }
              }
              if (ok) {
                  return h;
              } else h--;
          }
          return h;
      }
  };

:leetcode:`148`
---------------

单纯的排序，因为是自定义的链表结构体所以不能直接用标准库。
排序中简单好用的是快排和归并，因为是链表所以最终选择了归并排序。

.. code:: cpp

  using U = long long int;
  class Solution {
  public:
      ListNode* sortList(ListNode* head) {
          U len = 0;
          ListNode *i = head;
          while (i) {
              i = i->next;
              len++;
          }
          return mergeSort(head, len);
      }

      ListNode *mergeSort(ListNode *node, U len) {
          if (len <= 1) return node;
          ListNode *it = node;
          U llen = len / 2;
          U rlen = len - llen;
          for (U i = 0; i < llen - 1; i++) {
              it = it->next;
          }
          ListNode *r = it->next;
          it->next = NULL;
          ListNode *l = mergeSort(node, llen);
          r = mergeSort(r, rlen);
          return merge(l, llen, r, rlen);
      }

      ListNode *merge(ListNode *l, U llen, ListNode *r, U rlen) {
          ListNode *head;
          ListNode *lit = l;
          ListNode *rit = r;
          U lc = 0, rc = 0;
          if (l->val < r->val) {
              head = l;
              lit = l->next;
              lc = 1;
          } else {
              head = r;
              rit = r->next;
              rc = 1;
          }
          ListNode *it = head;
          for (;;) {
              if (!(lit || rit)) break;
              if (!lit) {
                  it->next = rit;
                  it = rit;
                  rit = rit->next;
                  rc++;
              } else if (!rit) {
                  it->next = lit;
                  it = lit;
                  lit = lit->next;
                  lc++;
              } else {
                  if (lit->val < rit->val) {
                      it->next = lit;
                      it = lit;
                      lit = lit->next;
                      lc++;
                  } else {
                      it->next = rit;
                      it = rit;
                      rit = rit->next;
                      rc++;
                  }
              }
          }
          return head;
      }
  };
