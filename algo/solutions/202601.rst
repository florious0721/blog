2026 å¹´ 1 æœˆ
############

:luogu:`P1219`
--------------

DFS + å›æº¯ã€‚
ä¸€ä¸ªé‡è¦çš„æŠ€å·§æ˜¯ä¸ç”¨äºŒç»´æ•°ç»„è¡¨ç¤ºæ£‹ç›˜ï¼Œ
è€Œæ˜¯å°† è¡Œã€åˆ— å’Œ å¯¹è§’çº¿ åˆ†åˆ«ç”¨æ•°ç»„å­˜å‚¨ï¼Œ
å¯ä»¥æé«˜åˆ¤æ–­å’Œæ’¤å›çš„æ•ˆç‡ã€‚

.. code:: cpp

  #include <cstdio>
  char rows[16] = {0}, cols[16] = {0}, bvps[32] = {0}, bvns[32] = {0};
  int ans[16] = {0};
  int row = 1;
  int n = 0;
  int anscount = 0;
  bool canplace(int row) {
      int col = ans[row];
      int bvp = row + col - 1;
      int bvn = n - row + col;
      if (rows[row] || cols[col] || bvps[bvp] || bvns[bvn]) {
          return false;
      } else return true;
  }
  void place(int row) {
      int col = ans[row];
      int bvp = row + col - 1;
      int bvn = n - row + col;
      rows[row] = 1;
      cols[col] = 1;
      bvps[bvp] = 1;
      bvns[bvn] = 1;
  }
  void drawback(int row) {
      int col = ans[row];
      int bvp = row + col - 1;
      int bvn = n - row + col;
      rows[row] = 0;
      cols[col] = 0;
      bvps[bvp] = 0;
      bvns[bvn] = 0;
  }

  int main(void) {
      scanf("%d", &n);

      int c = 3;
      int row = 1;
      ans[row] = 1;
      for (;;) {
          if (row == 1 && ans[row] > n) {
              break;
          }
          if (row > n) {
              if (c-- > 0) {
                  for (int i = 1; i <= n; i++) {
                      printf("%d ", ans[i]);
                  }
                  putchar('\n');
              }
              anscount++;
              row--;
              drawback(row);
              ans[row]++;
              continue;
          }
          if (ans[row] > n) {
              row--;
              drawback(row);
              ans[row]++;
              continue;
          }
          if (canplace(row)) {
              place(row);
              row++;
              ans[row] = 1;
          } else {
              ans[row]++;
          }
      }
      printf("%d\n", anscount);
  }

:luogu:`P1506`
--------------

bfs æˆ– dfs æ¨¡æ‹Ÿæ°´æ·¹å³å¯ï¼Œä¹‹åå†éå†ç»Ÿè®¡æ²¡è¢«æ·¹çš„ ``0``ã€‚

.. code:: cpp

  #include <cstdio>
  #include <cstdlib>
  #include <queue>
  #include <cctype>

  int n = 500, m = 500;
  char map[512][512];

  void dfs(int row, int col) {
      if (row <= 0 || n < row || col <= 0 || m < col || map[row][col]) {
          return;
      }
      map[row][col] = 1;
      dfs(row + 1, col);
      dfs(row - 1, col);
      dfs(row, col + 1);
      dfs(row, col - 1);
  }

  int main(void) {
      scanf("%d%d", &n, &m);
      {
          char c = getchar();
          while (isspace(c)) c = getchar();
          ungetc(c, stdin);
      }
      for (int i = 1; i <= n; i++) {
          for (int j = 1; j <= m; j++) {
              char c = getchar();
              if (c == '0') {
                  map[i][j] = 0;
              } else if (c == '*') {
                  map[i][j] = 1;
              } else {
                  exit(9);
              }
          }
          {
              char c = getchar();
              while (isspace(c)) c = getchar();
              ungetc(c, stdin);
          }
      }
      for (int i = 1; i <= m; i++) {
          dfs(1, i);
          dfs(n, i);
      }
      for (int i = 1; i <= n; i++) {
          dfs(i, 1);
          dfs(i, m);
      }
      int ans = 0;
      for (int i = 1; i <= n; i++) {
          for (int j = 1; j <= m; j++) {
              int x = map[i][j];
              if (x == 0) ans++;
          }
      }
      printf("%d\n", ans);
  }

:luogu:`P1162`
--------------

å¤§è‡´ä¸ :ref:`lgp1506` ç›¸åŒã€‚

.. code:: cpp

  #include <cstdio>
  #include <queue>

  typedef struct point {
      int x;
      int y;
  } point;

  int n = 32;
  int map[32][32] = {0};

  int main(void) {
      scanf("%d", &n);
      for (int i = 0; i < n; i++) {
          for (int j = 0; j < n; j++) {
              scanf("%d", &map[i][j]);
          }
      }
      std::queue<point>q;
      for (int i = 0; i < n; i++) {
          q.push(point {0, i});
          q.push(point {n - 1, i});
      }
      for (int i = 1; i < n - 1; i++) {
          q.push(point {i, 0});
          q.push(point {i, n - 1});
      }
      for (;;) {
          if (q.empty()) break;
          point top = q.front();
          q.pop();
          if (
              top.x < 0 || n <= top.x ||
              top.y < 0 || n <= top.y ||
              map[top.x][top.y] != 0
          ) {
              continue;
          }
          map[top.x][top.y] = 3;
          point l {top.x - 1, top.y};
          point r {top.x + 1, top.y};
          point u {top.x, top.y - 1};
          point d {top.x, top.y + 1};
          auto list = {l, r, u, d};
          for (auto i: list) {
              q.push(i);
          }
      }
      for (int i = 0; i < n; i++) {
          for (int j = 0; j < n; j++) {
              int m = map[i][j];
              printf("%d ", m == 0 ? 2 : m == 1 ? 1 : 0);
          }
          putchar('\n');
      }
  }

:luogu:`P1649`
--------------

bfs å¯»è·¯ï¼Œæœ€åé€‰è½¬å¼¯æ¬¡æ•°æœ€å°‘çš„å³å¯ã€‚
æœ€çŸ­è·¯å¾„æœªå¿…æ‹å¼¯æœ€å°‘ï¼Œæ‰€ä»¥æ ¼å­æ˜¯æœ‰å¯èƒ½å¤šæ¬¡è¢«èµ°è¿‡çš„ï¼Œ
éš¾ç‚¹åœ¨äºåœ¨è¿™ç§æƒ…å†µä¸‹å¦‚ä½•ç­›æ‰æ— æ•ˆè·¯å¾„ã€‚

ä¸€ç§åšæ³•æ˜¯å†å¼€ä¸€ä¸ªäºŒç»´æ•°ç»„è®°å½•åˆ°æ¯ä¸ªæ ¼å­çš„æœ€å°‘è½¬å¼¯æ¬¡æ•°ï¼Œ
å¦‚æœèµ°åˆ°è¿™ä¸ªæ ¼å­å‘ç°å½“å‰è·¯å¾„çš„è½¬å¼¯æ¬¡æ•°å¤§äºè¿™ä¸ªæœ€å°‘è½¬å¼¯æ¬¡æ•°åˆ™å‰ªæï¼Œ
å¦åˆ™æ›´æ–°è¿™ä¸ªæ ¼å­çš„æœ€å°‘è½¬å¼¯æ¬¡æ•°ã€‚

è¿˜æœ‰å°±æ˜¯è¦æ³¨æ„è¾“å…¥çš„æ–¹å¼ï¼Œå¹¶éæ‰€æœ‰æµ‹è¯•ç‚¹éƒ½åƒæ ·ä¾‹ä¸€æ ·æ˜¯ä¸€è¡Œä¹‹é—´å„ä¸ªå­—ç¬¦ç”¨ç©ºæ ¼éš”å¼€ã€‚

.. code:: cpp

  #include <cctype>
  #include <climits>
  #include <cstdio>
  #include <queue>

  typedef enum {
       NONE = -1, UP = 0, DOWN, LEFT, RIGHT,
  } direction;

  typedef struct {
      int row;
      int col;
      int turns;
      direction dir;
  } step;

  char map[128][128] = {0};
  int count[128][128] = {0};
  int n = 100;
  step A = {0}, B = {0};

  int main(void) {
      std::queue<step> q;
      scanf("%d", &n);
      {
          char c = getchar();
          while (isspace(c)) c = getchar();
          ungetc(c, stdin);
      }
      for (int i = 0; i < n; i++) {
          for (int j = 0; j < n; j++) {
              char c = getchar();
              while (c != 'A' && c != 'B' && c != '.' && c != 'x') c = getchar();
              if (c == 'A') {
                  A.row = i;
                  A.col = j;
              } else if (c == 'B') {
                  B.row = i;
                  B.col = j;
              }
              map[i][j] = c;
              count[i][j] = INT_MAX;
          }
      }
      A.turns = 0;
      A.dir = NONE;
      q.push(A);
      int ans = INT_MAX;
      for (;;) {
          if (q.empty()) break;

          step s = q.front();
          q.pop();
          if (s.turns > ans) continue;

          step u = {s.row - 1, s.col, s.turns, UP};
          step d = {s.row + 1, s.col, s.turns, DOWN};
          step l = {s.row, s.col - 1, s.turns, LEFT};
          step r = {s.row, s.col + 1, s.turns, RIGHT};
          for (auto i: {u, d, l, r}) {
              if (s.dir != i.dir && s.dir != NONE) i.turns++;
              if (i.row < 0 || i.row >= n || i.col < 0 || i.col >= n) continue;

              char& c = map[i.row][i.col];
              int& t = count[i.row][i.col];
              if ((c == ',' && i.turns > t) || c == 'x') continue;
              c = ',';
              t = i.turns < t ? i.turns : t; // ?
              if (i.row == B.row && i.col == B.col) {
                  ans = i.turns < ans ? i.turns : ans;
                  continue;
              }

              q.push(i);
          }
      }
      if (ans == INT_MAX) printf("-1\n");
      else printf("%d\n", ans);
  }

:vjudge:`HDU-1213`
------------------

å¹¶æŸ¥é›†ï¼Œæœ€åç»Ÿè®¡æœ‰å¤šå°‘ä¸ªæ ¹èŠ‚ç‚¹å³å¯ã€‚

`æäº¤ <https://vjudge.net/solution/67140505/iifjBkHX5yvNvKjSk52K>`_

:luogu:`P2024`
--------------

ç”¨ä¸‰å€çš„ç§ç±»å¹¶æŸ¥é›†è¡¨ç¤ºæ•é£Ÿå’Œå¤©æ•Œå…³ç³»å³å¯ã€‚
æˆ‘æ˜¯ğŸ–ï¼Œæœ€åå†™äº†ä¸ª :code:`animals[find(x+N+N)] = find(y);`ï¼Œ
çœ‹äº†é¢˜è§£æ‰çŸ¥é“è‡ªå·±å“ªé”™äº†ã€‚

.. code:: cpp

  #include <cstdio>

  int animals[100000 * 3 + 0x100];
  int N = 50000;

  int find(int x) {
      return animals[x] == x ? x : animals[x] = find(animals[x]);
  }

  int main(void) {
      int K = 100000;
      scanf("%d%d", &N, &K);
      for (int i = 1; i <= N * 3; i++) {
          animals[i] = i;
      }
      int ans = 0;
      for (; K > 0; K--) {
          int s, x, y;
          scanf("%d%d%d", &s, &x, &y);

          if (x > N || y > N) {
              ans++;
              continue;
          }

          if (s == 1) {
              if (find(x + N) == find(y) || find(x) == find(y + N)) {
                  ans++;
              } else {
                  animals[find(y)] = find(x);
                  animals[find(y + N)] = find(x + N);
                  animals[find(y + N + N)] = find(x + N + N);
              }
          } else {
              if (find(x) == find(y) || find(x) == find(y + N)) {
                  ans++;
              } else {
                  animals[find(x)] = find(y + N + N);
                  animals[find(x + N)] = find(y);
                  animals[find(x + N + N)] = find(y + N);
              }
          }
      }
      printf("%d\n", ans);
  }

:luogu:`P3369`
--------------

å°è¯•ä½¿ç”¨æ›¿ç½ªç¾Šæ ‘ï¼Œä½†æœ€åä¸€ä¸ªæµ‹è¯•ç‚¹è¿‡ä¸äº†ã€‚
ä¹Ÿè®¸æ˜¯æˆ‘æŠŠé‡å¤æ¬¡æ•°å­˜åˆ°èŠ‚ç‚¹é‡Œå¯¼è‡´çš„ã€‚

.. code:: cpp

  #include <array>
  #include <vector>
  #include <cstdio>
  #include <cstdlib>
  #include <iostream>
  #include <cctype>

  constexpr double alpha = 0.7;

  struct node {
      int lc, rc;
      int capa, len;
      int val, cnt;
      bool exists;

      node(): lc(0), rc(0), capa(0), len(0), val(0), cnt(0), exists(false) {}

      void reset() {
          lc = rc = capa = len = val = cnt = exists = 0;
      }
      void set(int v) {
          lc = rc = 0;
          val = v;
          cnt = capa = len = 1;
          exists = true;
      }
  };

  struct tree {
      std::array<node, 100000 + 0x100>arr;
      std::vector<int>vec;
      int acc = 0;
      int root = 0;
      tree() = default;

      // node &g(int node) {return arr[node];}
      node &glc(int nod) {return arr[arr[nod].lc];}
      node &grc(int nod) {return arr[arr[nod].rc];}

      bool need_rebuild(int nod) {
          return std::max(
              glc(nod).capa,
              grc(nod).capa
          ) > arr[nod].capa * alpha
                 || arr[nod].len < arr[nod].capa * alpha;
      }

      void travel(int nod) {
          if (!nod) return;
          travel(arr[nod].lc);
          if (arr[nod].exists) vec.push_back(nod);
          travel(arr[nod].rc);
          if (!arr[nod].exists) arr[nod].reset();
      }

      int lift(int l, int r) {
          if (l == r) {
              int nod = vec[l];
              node &n = arr[nod];
              n.lc = n.rc = 0;
              n.capa = n.len = n.cnt;
              n.exists = true;
              return nod;
          }
          int m = (l + r) / 2;
          // while (l < m && arr[vec[m]].val == arr[vec[m - 1]].val) m--;
          int nod = vec[m];
          node &n = arr[nod];
          if (l < m) n.lc = lift(l, m - 1);
          else n.lc = 0;
          n.rc = lift(m + 1, r);
          n.capa = arr[n.lc].capa + arr[n.rc].capa + n.cnt;
          n.len = arr[n.lc].len + arr[n.rc].len + n.cnt;
          return nod;
      }

      int rebuild(int nod) {
          vec.clear();
          travel(nod);
          if (vec.empty()) return 0;
          return lift(0, vec.size() - 1);
      }

      void refresh(int nod, int end) {
          if (!nod) return;
          if (arr[end].val < arr[nod].val) refresh(arr[nod].lc, end);
          else refresh(arr[nod].rc, end);
          node &n = arr[nod];
          n.capa = arr[n.lc].capa + arr[n.rc].capa + n.cnt;
          n.len = arr[n.lc].len + arr[n.rc].len + n.cnt;
      }

      void check(int nod, int end) {
          if (nod == end) return;
          if (nod == root) {
              if (need_rebuild(root)) root = rebuild(root);
              return;
          }
          if (arr[end].val < arr[nod].val) {
              int olc = arr[nod].lc;
              if (need_rebuild(olc)) {
                  arr[nod].lc = rebuild(olc);
                  refresh(root, arr[nod].lc);
              } else check(olc, end);
          } else {
              int orc = arr[nod].rc;
              if (need_rebuild(orc)) {
                  arr[nod].rc = rebuild(orc);
                  refresh(root, arr[nod].rc);
              } else check(orc, end);
          }
      }

      void insert(int v) {
          if (!root) {
              root = ++acc;
              arr[root].set(v);
              return;
          } else return _insert(v, root);
      }

      void remove(int v) {
          if (!root) exit(1);
          _remove(v, root);
      }

      void _insert(int v, int nod) {
          node &n = arr[nod];
          n.capa++;
          n.len++;
          if (v == n.val) {
              n.cnt++;
              return;
          } else if (v < n.val) {
              if (!n.lc) {
                  n.lc = ++acc;
                  glc(nod).set(v);
                  check(root, n.lc);
                  return;
              } else return _insert(v, n.lc);
          } else {
              if (!n.rc) {
                  n.rc = ++acc;
                  grc(nod).set(v);
                  check(root, n.rc);
                  return;
              } else return _insert(v, n.rc);
          }
      }
      void _remove(int v, int nod) {
          if (!nod) exit(2);
          node &n = arr[nod];
          if (v == n.val) {
              if (n.cnt <= 0) exit(3);
              if (--n.cnt <= 0) {
                  n.exists = false;
              }
              n.len--;
              check(root, nod);
              return;
          }
          n.len--;
          if (v < n.val) _remove(v, n.lc);
          else _remove(v, n.rc);
      }

      int getrank(int v) {
          int nod = root, rank = 1;
          while (nod) {
              if (v == arr[nod].val) {
                  return glc(nod).len + rank;
              } else if (v < arr[nod].val) {
                  nod = arr[nod].lc;
              } else {
                  rank += arr[nod].cnt + glc(nod).len;
                  nod = arr[nod].rc;
              }
          }
          return rank;
      }

      int getval(int rank) {
          int nod = root;
          while (nod) {
              int llen = arr[nod].cnt + glc(nod).len;
              if (rank <= glc(nod).len) nod = arr[nod].lc;
              else if (rank <= llen) return arr[nod].val;
              else {
                  rank -= llen;
                  nod = arr[nod].rc;
              }
          }
          exit(4);
      }
  };

  void atoi(int &x) {
      bool neg = false;
      x = 0;
      char ch = 0;
      while (!std::isdigit(ch)) {
          if (ch == '-') neg = true;
          ch = getchar();
      }
      if (neg) {
          while (isdigit(ch)) {
              x = x * 10 + ('0' - ch);
              ch = getchar();
          }
      } else {
          while (isdigit(ch)) {
              x = x * 10 + (ch - '0');
              ch = getchar();
          }
      }
  }

  void itoa(int x) {
      bool neg = false;
      if (x < 0) {
          neg = true;
          putchar('-');
      }
      static int sta[40];
      int top = 0;
      do {
          sta[top++] = x % 10;
          x /= 10;
      } while (x);
      if (neg)
          while (top) putchar('0' - sta[--top]);
      else
          while (top) putchar('0' + sta[--top]);
  }

  char buf[0x10000];

  int main(void) {
      std::cin.tie(nullptr);
      std::ios_base::sync_with_stdio(false);

      tree t;
      int n;
      atoi(n);
      while (n--) {
          int opt, x, ans;
          atoi(opt);
          atoi(x);
          switch (opt) {
          case 1:
              t.insert(x);
              break;
          case 2:
              t.remove(x);
              break;
          case 3:
              ans = t.getrank(x);
              itoa(ans);
              putchar('\n');
              break;
          case 4:
              ans = t.getval(x);
              itoa(ans);
              putchar('\n');
              break;
          case 5:
              ans = t.getval(t.getrank(x) - 1);
              itoa(ans);
              putchar('\n');
              break;
          case 6:
              ans = t.getval(t.getrank(x + 1));
              itoa(ans);
              putchar('\n');
              break;
          default: return 9;
          }
      }
      return 0;
  }
