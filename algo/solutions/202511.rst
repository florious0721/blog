2025 年 11 月
#############

:leetcode:`852`
---------------

  给定一个长度为 ``n`` 的整数 **山脉** 数组 ``arr`` ，
  其中的值递增到一个 **峰值元素** 然后递减。
  返回峰值元素的下标。
  你必须设计并实现时间复杂度为 ``O(log(n))`` 的解决方案。

二分查找，右边更高将区间右移，左边更高将区间左移，
否则缩小区间范围，直到
``arr[mid - 1] < arr[mid] && arr[mid] < arr[mid + 1]``。

.. code:: cpp

  class Solution {
  public:
      int peakIndexInMountainArray(vector<int>& arr) {
          int left = 0;
          int right = arr.size() - 1;
          int mid = (left + right) / 2;
          for (;;) {
              int leftmid = (left + mid) / 2;
              int rightmid = (mid + right) / 2;
              if (arr[leftmid] > arr[mid]) {
                  right = mid;
                  mid = leftmid;
              } else if (arr[rightmid] > arr[mid]) {
                  left = mid;
                  mid = rightmid;
              } else {
                  left = leftmid;
                  right = rightmid;
              }
              if (arr[mid - 1] < arr[mid] && arr[mid] > arr[mid + 1]) return mid;
          }
          return -1;
      }
  };

:luogu:`P1440`
--------------

  一个含有 *n* 项的数列，
  求出每一项前的 *m* 个数到它这个区间内的最小值。
  若前面的数不足 *m* 项则从第 *1* 个数开始，
  若前面没有数则输出 *0*。

暴力
____

我们可以记录下当前窗口内的最小值，
接着考虑窗口内的数、即将出窗口的数、即将进窗口的数，
若进的数比当前最小值更小，更新最小值，
若出的数是当前的最小值，那么重新求窗口内的最小值。

最后一组数据 TLE。

.. code:: cpp

  #include <stdio.h>
  #include <algorithm>
  #include <vector>
  typedef unsigned long ulong;
  int main(void) {
      int n, m;
      ulong min = 0xffffffff;
      std::vector<ulong> v;
      scanf("%d%d", &n, &m);
      for (int i = 0; i < n; ++i) {
          ulong j;
          scanf("%lu", &j);
          v.push_back(j);
      }
      auto l = v.begin();
      auto r = l;
      puts("0");
      while (r - l < m) {
          min = *r < min ? *r : min;
          ++r;
          printf("%lu\n", min);
      }
      auto tail = v.end() - 1;
      while (r != tail) {
          if (*r < min) {
              min = *r;
          } else if (*l == min) {
              min = *std::min_element(l + 1, r + 1);
          }
          printf("%lu\n", min);
          ++r;
          ++l;
      }
      return 0;
  }

单调队列
________

对上面的方法进一步优化，关键在于剔除那些不可能成为窗口内最小值的数。
我们用单调队列存储这个滑动窗口，
对于一个即将进入窗口的数 :math:`a_i`，
只要它在窗口内，那么比它大的数都无法成为最小值，
所以可以把队列里比它大的数都弹出，
这样我们就可以确保队列是单调递增的，
队头则为当前窗口内的最小值，
接着再在每次移动窗口时把超过窗口范围的数弹出即可。

.. code:: cpp

  #include <stdio.h>
  #include <algorithm>
  #include <deque>
  #include <vector>

  typedef unsigned long ulong;
  typedef struct {
      ulong val;
      long idx;
  } node;

  int main(void) {
      ulong n;
      long m;
      scanf("%lu%ld", &n, &m);
      std::deque<node> q;
      puts("0");
      for (long i = 0; i < n - 1; ++i) {
          ulong val;
          scanf("%lu", &val);
          while (!q.empty() && q.back().val > val) q.pop_back();
          q.push_back(node{val, i});
          if (!q.empty() && q.front().idx < i - (m - 1)) q.pop_front();
          printf("%lu\n", q.front().val);
      }
  }

:leetcode:`239`
---------------

  给你一个整数数组 ``nums``，
  有一个大小为 ``k`` 的滑动窗口从数组的最左侧移动到数组的最右侧。
  你只可以看到在滑动窗口内的 ``k`` 个数字。滑动窗口每次只向右移动一位。

  返回 *滑动窗口中的最大值*。

与 :ref:`lgp1440` 类似，反过来求最大值即可。

.. code:: cpp

  class Solution {
  public:
      vector<int> maxSlidingWindow(vector<int>& nums, int k) {
          vector<int> r;
          deque<int> q;
          int i = 0;
          for (; i < k; ++i) {
              while (!q.empty() && nums[q.back()] < nums[i]) q.pop_back();
              q.push_back(i);
          }
          r.push_back(nums[q.front()]);
          for (; i < nums.size(); ++i) {
              while (!q.empty() && nums[q.back()] < nums[i]) q.pop_back();
              q.push_back(i);
              if (!q.empty() && q.front() <= i - k) q.pop_front();
              r.push_back(nums[q.front()]);
          }
          return r;
      }
  };

:luogu:`P1714`
--------------

  形式化地，在数列 :math:`\lbrace p_n \rbrace` 中，
  找出一个字段 :math:`[l, r](r-l + 1 \leq m)`，
  最大化 :math:`\sum\limits_{i=l}^rp_i`。

这题就是在 :ref:`max_interval_sum` 的基础上限制了区间长度。
因为 :ref:`max_interval_sum` 需要频繁计算区间值，
所以用 :ref:`prefix_sum` 优化，
然后再用单调队列维护一个单调递增的前缀和进一步优化。

这题要注意弹出头、求值、弹出尾并插入新值的顺序。

.. code:: cpp

  #include <limits.h>
  #include <stdio.h>
  #include <queue>
  #include <vector>

  int main(void) {
      std::deque<long> q;
      long sumv[500000+0x100] = {0};

      long n, m;
      scanf("%ld%ld", &n, &m);

      long cur_sum = 0;
      for (long i = 1; i <= n; ++i) {
          long j = 0;
          scanf("%ld", &j);
          cur_sum += j;
          sumv[i] = cur_sum;
      }

      long ans = LONG_MIN;
      q.push_back(0);
      for (long i = 1; i <= n; ++i) {
          while (!q.empty() && i - q.front() > m) q.pop_front();
          long new_ans = sumv[i] - sumv[q.front()];
          ans = new_ans > ans ? new_ans : ans;
          while (!q.empty() && sumv[q.back()] >= sumv[i]) q.pop_back();
          q.push_back(i);
      }

      printf("%ld\n", ans);
      return 0;
  }

:luogu:`P2032`
--------------

同 :ref:`lc239` 略。

:leetcode:`2080`
----------------

  请你设计一个数据结构，它能求出给定子数组内一个给定值的 **频率**。
  子数组中一个值的 **频率** 指的是这个子数组中这个值的出现次数。

  请你实现 ``RangeFreqQuery`` 类：

  * ``RangeFreqQuery(int[] arr)``
    用下标从 **0** 开始的整数数组 ``arr`` 构造一个类的实例。
  * ``int query(int left, int right, int value)``
    返回子数组 ``arr[left...right]`` 中 ``value`` 的 **频率**。

  一个 **子数组** 指的是数组中一段连续的元素。
  ``arr[left...right]`` 指的是
  ``nums`` 中包含下标 ``left`` 和 ``right`` **在内** 的中间一段连续元素。

要查找序列中某区间内某个值出现的次数，
用暴力方法的话每次查询都要将区间遍历一遍。
用 :ref:`log_position` 的方法，
将各个值在序列中出现的位置用数组存储起来，
那么我们知道 ``left`` 和 ``right`` 在这个位置的数组里的索引之后
就可以轻松求出出现的次数。
现在的问题是如何快速地在位置的数组里找到 ``left`` 和 ``right``，
因为我们是按顺序读取输入的，所以位置数组是有序的，
可以用二分查找优化。

.. code:: cpp

  class RangeFreqQuery {
  public:
      unordered_map<int, vector<int>> m;
      RangeFreqQuery(vector<int>& arr) {
          int i = 0;
          for (auto j: arr) {
              m[j].push_back(i);
              ++i;
          }
      }

      int query(int left, int right, int value) {
          auto i = m.find(value);
          if (i == m.end()) return 0;
          auto& v = i->second; // 注意用引用或者指针防止拷贝，不然会超时

          auto l = lower_bound(v.begin(), v.end(), left);
          auto r = upper_bound(v.begin(), v.end(), right);
          return r - l;
      }
  };

:luogu:`P1449`
--------------

  所谓后缀表达式是指这样的一个表达式：
  式中不再引用括号，运算符号放在两个运算对象之后，
  所有计算按运算符号出现的顺序，
  严格地由左而右进行（不用考虑运算符的优先级）。

  本题中运算符仅包含 :strong:`+-*/`。
  保证对于 / 运算除数不为 0。
  特别地，其中 / 运算的结果需要
  **向 0 取整** （即与 C++ ``/`` 运算的规则一致）。

  如：``3*(5-2)+7`` 对应的后缀表达式为：``3.5.2.-*7.+@``。
  在该式中，``@`` 为表达式的结束符号。``.`` 为操作数的结束符号。

因为之前写过一个计算器所以知道要用栈，
现在我们再思考一下为什么用栈。

表达式中会遇到的记号可以分为两类：操作数 和 运算符。
后缀表达式中操作数在前，运算符在后，
我们遇到操作数时并不知道要进行何种运算，
只能先存储起来；
如果表达式合法，我们在遇到运算符时
就要取出最后存进去的一定量的操作数进行运算，
这就是我们用栈的原因，后进先出。

.. code:: cpp

  #include <ctype.h>
  #include <stdio.h>

  int stack[0x100] = {0};

  int main(void) {
      int top = 0;
      for (;;) {
          char ch = getchar();
          if (ch == '@') break;
          int i;
          if (isdigit(ch)) {
              ungetc(ch, stdin);
              scanf("%d", &i);
              stack[top++] = i;
              getchar();
          } else {
              int rhs = stack[--top];
              int lhs = stack[--top];
              switch (ch) {
              case '+':
                  stack[top++] = lhs + rhs;
                  break;
              case '-':
                  stack[top++] = lhs - rhs;
                  break;
              case '*':
                  stack[top++] = lhs * rhs;
                  break;
              case '/':
                  stack[top++] = lhs / rhs;
                  break;
              }
          }
      }
      printf("%d\n", stack[--top]);
  }

:luogu:`P1739`
--------------

  假设一个表达式有英文字母（小写）、运算符（``+``、``-``、``*``、``/``）
  和左右小（圆）括号构成，以 ``@`` 作为表达式的结束符。
  请编写一个程序检查表达式中的左右圆括号是否匹配，若匹配，
  则输出 ``YES``；否则输出 ``NO``。表达式长度小于 255，左圆括号少于 20 个。

用一个数 ``i`` 记录当前括号深度，
遇到 ``(`` 时，``i`` 自增；
遇到 ``)`` 时，``i`` 自减。
如果遇到 ``)`` 时，``i`` 小于等于 0，输出 ``NO`` 并结束。
如果扫描完表达式后发现 ``i`` 不等于 0，输出 ``NO`` 并结束；
否则输出 ``YES``，结束。

.. code:: cpp

   #include <stdio.h>

  int main(void) {
      int i = 0;
      char ch = 0;
      for (;;) {
          ch = getchar();
          if (ch == '@') break;
          else if (ch == '(') ++i;
          else if (ch == ')') {
              if (i < 1) {
                  puts("NO");
                  return 0;
              } else --i;
          }
      }
      if (i > 0) {
          puts("NO");
      } else {
          puts("YES");
      }
      return 0;
  }

:luogu:`P5788`
--------------

  给出项数为 :math:`n` 的整数数列 :math:`a_{1\dots n}`。

  定义函数 :math:`f(i)` 代表数列中第 :math:`i` 个元素之后第一个
  大于 :math:`a_i` 的元素的 **下标**，即
  :math:`f(i)=\min_{i<j\leq n,a_j>q_i}\lbrace j\rbrace`。
  若不存在，则 :math:`f(i) = 0`。

  试求 :math:`f(1\dots n)`。

既然题目名里有单调栈那就先想一想应该构建一个单调递增还是单调递减的栈，
也就是我们何时能够抛弃一项。对样例 ``1 4 2 3 5``，很容易想到当我们读到
``4`` 时就可以把第一项 ``1`` 抛弃，也就是说当栈顶比新项小时将栈顶弹出，
我们要构建一个单调递减的栈。

那么被抛弃的第一项对应的 :math:`f(1)` 又是什么呢？
就是我们放入的新项的索引 ``2`` （从 1 开始）。

然后答案就出来了：构建一个单调递减的栈。栈顶被弹出时，
被弹出的项的索引 :math:`i` 对应的 :math:`f(i)` 就是放入的新项的索引。

.. code:: cpp

  #include <stdio.h>
  typedef unsigned long ulong;

  int a[3000000 + 0x100] = {0};
  int stack[3000000 + 0x100] = {0};
  int r[3000000 + 0x100] = {0};

  int main(void) {
      ulong top = 0;

      ulong n;
      scanf("%lu", &n);
      for (ulong i = 1; i <= n; ++i) {
          int j;
          scanf("%d", &j);
          a[i] = j;
          while (top != 0 && a[stack[top - 1]] < j) r[stack[--top]] = i;
          stack[top++] = i;
      }
      while (top) {
          r[stack[--top]] = 0;
      };
      for (ulong i = 1; i <= n; ++i) {
          printf("%d ", r[i]);
      }
      putchar('\n');
      return 0;
  }

:luogu:`P1087`
--------------

  我们可以把由 0 和 1 组成的字符串分为三类：
  全 0 串称为 B 串，全 1 串称为 I 串，
  既含 0 又含 1 的串则称为 F 串。

  FBI 树是一种二叉树，
  它的结点类型也包括 F 结点，B 结点和 I 结点三种。
  由一个长度为 :math:`2^N` 的 01 串 :math:`S`
  可以构造出一棵 FBI 树 :math:`T`，
  递归的构造方法如下：

  #. :math:`T` 的根节点为 :math:`R`，其类型与串 :math:`S` 的类型相同；
  #. 若串 :math:`S` 的长度大于 1，将串 :math:`S` 从中间分开，
     分为等长的左右字串 :math:`S_1` 和 :math:`S_2`；
     由左子串 :math:`S_1` 构造 :math:`R` 的左子树 :math:`T_1`，
     由右子串 :math:`S_2` 构造 :math:`R` 的右子树 :math:`T_2`。

  现在给定一个长度为 :math:`2^N` 的 01 串，请用上述构造方法构造出
  一棵 FBI 树，并输出它的后序遍序序列。

:ref:`binary_tree` 练习题，按定义构建即可。

.. code:: cpp

  #include <stdio.h>
  #include <ctype.h>

  char str[0x1000] = {0};
  char tree[0x1000] = {0};

  void buildBI(int idx, int len, char BI) {
      if (len < 1) return;
      tree[idx] = BI;
      if (len <= 1) return;
      buildBI(idx * 2 + 1, len / 2, BI);
      buildBI(idx * 2 + 2, len / 2, BI);
  }
  void buildU(int idx, char *s, int len) {
      bool has_zero = false;
      bool has_one = false;
      char BI;
      for (
          char const *i = s, *end = s + len;
          i < end; ++i
      ) {
          if (has_zero && has_one) break;
          if (*i == '0') has_zero = true;
          if (*i == '1') has_one = true;
      }
      if (has_zero && has_one) {
          tree[idx] = 'F';
          buildU(idx * 2 + 1, s, len / 2);
          buildU(idx * 2 + 2, s + len / 2, len / 2);
          return;
      } else if (has_zero) {
          BI = 'B';
      } else if (has_one) {
          BI = 'I';
      } else {
          puts("Unknown error");
      }
      tree[idx] = BI;
      buildBI(idx * 2 + 1, len / 2, BI);
      buildBI(idx * 2 + 2, len / 2, BI);
  }

  void postIter(int idx) {
      if (tree[idx] == 0) return;
      postIter(idx * 2 + 1);
      postIter(idx * 2 + 2);
      putchar(tree[idx]);
  }

  int main(void) {
      int N = 0;
      scanf("%d", &N);
      char ch;
      do ch = getchar(); while (isspace(ch));
      ungetc(ch, stdin);
      for (int i = 0; i < (1 << N); ++i) {
          str[i] = getchar();
      }
      buildU(0, str, 1 << N);
      postIter(0);
  }
